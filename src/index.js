/**
 * Cloudflare Workers ‚Äî Telegram bot webhook.
 * Env vars (set in Wrangler / Dashboard):
 * - BOT_TOKEN         (string, required)
 * - WEBHOOK_SECRET    (string, required)
 * - API_BASE_URL      (string, optional, default "https://api.telegram.org")
 * - STATE             (KV Namespace, optional)
 */

/** @typedef {import('@cloudflare/workers-types').KVNamespace} KVNamespace */

const JSON_HEADERS = { "content-type": "application/json; charset=utf-8" };

/**
 * Send a request to Telegram Bot API
 * @param {Env} env
 * @param {string} method e.g. "sendMessage"
 * @param {any} body
 */
async function tg(env, method, body) {
  const base = (env.API_BASE_URL || "https://api.telegram.org").replace(/\/+$/, "");
  const url = `${base}/bot${env.BOT_TOKEN}/${method}`;
  return fetch(url, {
    method: "POST",
    headers: JSON_HEADERS,
    body: JSON.stringify(body),
  });
}

/**
 * Safely parse request JSON
 * @param {Request} req
 */
async function readJson(req) {
  try {
    return await req.json();
  } catch {
    return null;
  }
}

/**
 * Small helpers
 */
const ok = (data = {}) => new Response(JSON.stringify({ ok: true, ...data }), { headers: JSON_HEADERS });
const err = (message, status = 200) =>
  // 200: —â–æ–± Telegram –Ω–µ —Ä–µ—Ç—Ä–∞—ó–≤. –£ –ª–æ–≥–∞—Ö –±—É–¥–µ –≤–∏–¥–Ω–æ –ø–æ–º–∏–ª–∫—É.
  new Response(JSON.stringify({ ok: false, error: String(message) }), {
    headers: JSON_HEADERS,
    status,
  });

/**
 * Handle Telegram update
 * @param {any} update
 * @param {Env} env
 */
async function handleUpdate(update, env) {
  const msg = update.message || update.edited_message || update.callback_query?.message;
  const chatId = msg?.chat?.id;

  // No chat ‚Äî nothing to do
  if (!chatId) return;

  // Text commands
  const text = (update.message?.text || "").trim();

  // KV helpers (optional, if STATE is bound)
  const kv = env.STATE;

  if (text === "/start") {
    await tg(env, "sendMessage", {
      chat_id: chatId,
      text: "üëã –ü—Ä–∏–≤—ñ—Ç! –ë–æ—Ç –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Cloudflare Workers.\n–°–ø—Ä–æ–±—É–π: /ping, –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ —Ç–µ–∫—Å—Ç, –∞–±–æ /kvset –∫–ª—é—á –∑–Ω–∞—á–µ–Ω–Ω—è, /kvget –∫–ª—é—á",
    });
    return;
  }

  if (text === "/ping") {
    await tg(env, "sendMessage", { chat_id: chatId, text: "pong ‚úÖ" });
    return;
  }

  if (text.startsWith("/kvset")) {
    const [, key, ...rest] = text.split(/\s+/);
    const value = rest.join(" ");
    if (!kv) {
      await tg(env, "sendMessage", { chat_id: chatId, text: "‚ùå KV –Ω–µ –ø—Ä–∏–≤'—è–∑–∞–Ω–æ (STATE)." });
      return;
    }
    if (!key || !value) {
      await tg(env, "sendMessage", { chat_id: chatId, text: "–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è: /kvset <key> <value>" });
      return;
    }
    await kv.put(key, value);
    await tg(env, "sendMessage", { chat_id: chatId, text: `‚úÖ –ó–±–µ—Ä–µ–∂–µ–Ω–æ: ${key} = ${value}` });
    return;
  }

  if (text.startsWith("/kvget")) {
    const [, key] = text.split(/\s+/);
    if (!kv) {
      await tg(env, "sendMessage", { chat_id: chatId, text: "‚ùå KV –Ω–µ –ø—Ä–∏–≤'—è–∑–∞–Ω–æ (STATE)." });
      return;
    }
    if (!key) {
      await tg(env, "sendMessage", { chat_id: chatId, text: "–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è: /kvget <key>" });
      return;
    }
    const value = await kv.get(key);
    await tg(env, "sendMessage", {
      chat_id: chatId,
      text: value != null ? `üóÑ ${key} = ${value}` : `üòï –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∫–ª—é—á: ${key}`,
    });
    return;
  }

  // Photo / Document acknowledgment
  if (msg?.photo || msg?.document) {
    await tg(env, "sendMessage", {
      chat_id: chatId,
      text: "üì∏ –î—è–∫—É—é! –û—Ç—Ä–∏–º–∞–≤ —Ñ–∞–π–ª.",
      reply_to_message_id: msg.message_id,
    });
    return;
  }

  // Echo for any other text
  if (text) {
    await tg(env, "sendMessage", {
      chat_id: chatId,
      text: `–¢–∏ –Ω–∞–ø–∏—Å–∞–≤: ${text}`,
      reply_to_message_id: msg.message_id,
    });
    return;
  }

  // Fallback: acknowledge update
  await tg(env, "sendMessage", { chat_id: chatId, text: "‚úÖ –û—Ç—Ä–∏–º–∞–≤ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è." });
}

/**
 * @typedef {Object} Env
 * @property {string} BOT_TOKEN
 * @property {string} WEBHOOK_SECRET
 * @property {string} [API_BASE_URL]
 * @property {KVNamespace} [STATE]
 */

export default {
  /**
   * @param {Request} request
   * @param {Env} env
   */
  async fetch(request, env) {
    const url = new URL(request.url);

    // Health
    if (request.method === "GET" && (url.pathname === "/" || url.pathname === "/healthz")) {
      return ok({ service: "senti-bot-worker", env: "ok" });
    }

    // Webhook endpoint: /webhook/<WEBHOOK_SECRET>
    if (url.pathname === `/webhook/${env.WEBHOOK_SECRET}`) {
      if (request.method !== "POST") return err("Method must be POST");
      const update = await readJson(request);
      if (!update) return err("Invalid JSON");

      // Handle in background; –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î–º–æ Telegram –º–∏—Ç—Ç—î–≤–æ
      // —â–æ–± –Ω–µ –ª–æ–≤–∏—Ç–∏ —Ç–∞–π–º–∞—É—Ç–∏ —Ç–∞ 404
      // (Cloudflare –¥–æ–∑–≤–æ–ª—è—î fire-and-forget –±–µ–∑ await)
      handleUpdate(update, env).catch((e) =>
        console.error("handleUpdate error:", e?.stack || e)
      );

      return ok({ received: true });
    }

    return new Response("Not found", { status: 404, headers: { "content-type": "text/plain" } });
  },
};